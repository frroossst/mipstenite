use clap::Parser;

use log::error;
use mipstenite::{parser::mock_parser, virtual_machine::VirtualMachine, bytecode::{Bytecode, AsmInstruction}, debug_table::{CompileDebugInfo, MachineState}, err_util::setup_logger};

#[derive(Debug, Parser)]
#[clap(author, version, about)]
struct Args {
	#[clap(required = true)]
	file_path: Option<String>,

	#[clap(long, short, action)]
	cleanup: bool,

	#[clap(long, short)]
	debug: bool,
}

fn main() {

	setup_logger();

	let args = Args::parse();
	
	// check if valid file path
	let file_path = args.file_path.clone();
	if file_path.is_some() {
		let file_path = file_path.unwrap();
		if !std::path::Path::new(&file_path).exists() {
			error!("Invalid file path");
			eprintln!("Invalid file path: {}", &file_path);
			std::process::exit(1);
		}
	}

	if args.cleanup {
			// remove all files with numbers in the name ending with .bin extension
			let files = std::fs::read_dir(".").unwrap();
			for file in files {
				let file = file.unwrap();
				let file_name = file.file_name();
				let file_name = file_name.to_str().unwrap();
				if file_name.ends_with(".bin") {
					let file_name = file_name.split(".bin").collect::<Vec<&str>>()[0];
					if file_name.parse::<u32>().is_ok() {
						std::fs::remove_file(file.path()).unwrap();
					}
				}
			}
		std::process::exit(0);
		}
	if args.debug {
		error!("not implementd");
	}

    let _src = r#"
        # ------------------------------------------------------------------
        	
        	.text
        main:
        	lw	$s0, x		# Reg $s0 = x
        	lw	$s1, y		# Reg $s1 = y
        
        	# Call function
        	move	$a0, $s0	# Argument 1: x ($s0)
        	jal	fun		# Save current PC in $ra, and jump to fun
        	move	$s1,$v0		# Return value saved in $v0. This is y ($s1)
        
        	# Print msg1
        	li	$v0, 4		# print_string syscall code = 4
        	la	$a0, msg1
        	syscall
        
        fun:	# This function overwrites $s0 and $s1
        	# We should save those on the stack
        	# This is PUSH'ing onto the stack
        	addi $sp,$sp,-4		# Adjust stack pointer
        	sw $s0,0($sp)		# Save $s0
        	addi $sp,$sp,-4		# Adjust stack pointer
        	sw $s1,0($sp)		# Save $s1
        
        	# Save the return value in $v0
        	move $v0,$s1
        
        	.data
        x:	.word 5
        y:	.word 0
        msg1:	.asciiz	"y="
        lf:     .asciiz	"\n"
        "#;

	let src = r#"
	# Program File: Program2-1.asm 
	# Author: Charles Kann
	# Purpose: First program, Hello World
	.text                   # Define the program instructions.
	main:                   # Label to define the main program.
	    li $v0,4            # Load 4 into $v0 to indicate a print string.
	    la $a0, greeting    # Load the address of the greeting into $a0.
	    syscall             # Print greeting. The print is indicated by
	                        # $v0 having a value of 4, and the string to
	                        # print is stored at the address in $a0.
	    li $v0, 10          # Load a 10 (halt) into $v0.
	    syscall             # The program ends.
	.data                   # Define the program data.
	greeting: .asciiz "Hello World" #The string to print.
	"#;

        let lxr_src = src;
		let result = mock_parser(lxr_src);
		let asm_instructions: Vec<AsmInstruction>;
		let mut byc_translations: Vec<Vec<Bytecode>> = Vec::new();
		if result.is_ok() {
			asm_instructions = result.unwrap().1;
		} else {
			println!("{:#?}", result);
			std::process::exit(1);
		}

		// construct a HashMap that maps line_number or usize to a tupe of (instruction, Vec<Bytecode>)
		// this allows for easy access of assembly instruction and generated bytecode for every line
		let compile_debug_info = CompileDebugInfo::new(asm_instructions.clone());

		let mut byc_instructions = asm_instructions.into_iter().map(|i| {
			let byc = i.to_bytecode();
			byc_translations.push(byc.clone());
			byc
		}).flatten().collect::<Vec<Bytecode>>();
		byc_instructions.push(Bytecode::TERMINATOR);

		let mut vm = VirtualMachine::new();
		vm.set_program(byc_instructions);
		vm.setup_debug(compile_debug_info);

		// Serialize the VM to a file
		vm.dump();

		loop {
			match vm.execute() {
				Ok(o) => {
					match o {
						MachineState::Running => {}
						MachineState::Halted => {
							break;
						}
					}	
				},
				Err(e) => {
					eprintln!("Error: {:?}", e);
					break;
				}
			}
		}

		vm.runtime_dbg.print_debug_info();

		println!("{:#?}", vm);

}
